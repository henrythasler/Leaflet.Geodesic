//created with http://lisperator.net/uglifyjs/parser
void 0===Number.prototype.toRadians&&(Number.prototype.toRadians=function(){return this*Math.PI/180}),void 0===Number.prototype.toDegrees&&(Number.prototype.toDegrees=function(){return 180*this/Math.PI})
var INTERSECT_LNG=179.999
L.Geodesic=L.MultiPolyline.extend({options:{color:"blue",steps:10,dash:1,wrap:!0},initialize:function(t,a){this.options=this._merge_options(this.options,a),this.datum={},this.datum.ellipsoid={a:6378137,b:6356752.3142,f:1/298.257223563},L.MultiPolyline.prototype.initialize.call(this,t,this.options)},setLatLngs:function(t){this._latlngs=this.options.dash<1?this._generate_GeodesicDashed(t):this._generate_Geodesic(t),L.MultiPolyline.prototype.setLatLngs.call(this,this._latlngs)},getStats:function(){var t,a,n={distance:0,points:0,polygons:this._latlngs.length}
for(t=0;t<this._latlngs.length;t++)for(n.points+=this._latlngs[t].length,a=0;a<this._latlngs[t].length-1;a++)n.distance+=this._vincenty_inverse(this._latlngs[t][a],this._latlngs[t][a+1]).distance
return n},createCircle:function(t,a){var n,s=[],i=0,e={lat:0,lng:0,brg:0}
s[i]=[]
var o=this._vincenty_direct(L.latLng(t),0,a,this.options.wrap)
for(e=L.latLng(o.lat,o.lng),s[i].push(e),n=1;n<=this.options.steps;){o=this._vincenty_direct(L.latLng(t),360/this.options.steps*n,a,this.options.wrap)
var h=L.latLng(o.lat,o.lng)
if(Math.abs(h.lng-e.lng)>180){var l=this._vincenty_inverse(e,h),r=this._intersection(e,l.initialBearing,{lat:-89,lng:h.lng-e.lng>0?-INTERSECT_LNG:INTERSECT_LNG},0)
r?(s[i].push(L.latLng(r.lat,r.lng)),i++,s[i]=[],e=L.latLng(r.lat,-r.lng),s[i].push(e)):(i++,s[i]=[],s[i].push(h),e=h,n++)}else s[i].push(h),e=h,n++}this._latlngs=s,L.MultiPolyline.prototype.setLatLngs.call(this,this._latlngs)},_generate_Geodesic:function(t){var a,n,s,i=[],e=0
for(n=0;n<t.length;n++){for(i[e]=[],s=0;s<t[n].length-1;s++){var o=this._vincenty_inverse(L.latLng(t[n][s]),L.latLng(t[n][s+1])),h=L.latLng(t[n][s])
for(i[e].push(h),a=1;a<=this.options.steps;){var l=this._vincenty_direct(L.latLng(t[n][s]),o.initialBearing,o.distance/this.options.steps*a,this.options.wrap),r=L.latLng(l.lat,l.lng)
if(Math.abs(r.lng-h.lng)>180){var g=this._intersection(L.latLng(t[n][s]),o.initialBearing,{lat:-89,lng:r.lng-h.lng>0?-INTERSECT_LNG:INTERSECT_LNG},0)
g?(i[e].push(L.latLng(g.lat,g.lng)),e++,i[e]=[],h=L.latLng(g.lat,-g.lng),i[e].push(h)):(e++,i[e]=[],i[e].push(r),h=r,a++)}else i[e].push(r),h=r,a++}}e++}return i},_generate_GeodesicDashed:function(t){var a,n,s,i=[],e=0
for(n=0;n<t.length;n++){for(i[e]=[],s=0;s<t[n].length-1;s++){var o=this._vincenty_inverse(L.latLng(t[n][s]),L.latLng(t[n][s+1])),h=L.latLng(t[n][s])
for(i[e].push(h),a=1;a<=this.options.steps;){var l=this._vincenty_direct(L.latLng(t[n][s]),o.initialBearing,o.distance/this.options.steps*a-o.distance/this.options.steps*(1-this.options.dash),this.options.wrap),r=L.latLng(l.lat,l.lng)
if(Math.abs(r.lng-h.lng)>180){var g=this._intersection(L.latLng(t[n][s]),o.initialBearing,{lat:-89,lng:r.lng-h.lng>0?-INTERSECT_LNG:INTERSECT_LNG},0)
g?(i[e].push(L.latLng(g.lat,g.lng)),e++,i[e]=[],h=L.latLng(g.lat,-g.lng),i[e].push(h)):(e++,i[e]=[],i[e].push(r),h=r,a++)}else{i[e].push(r),e++
var c=this._vincenty_direct(L.latLng(t[n][s]),o.initialBearing,o.distance/this.options.steps*a,this.options.wrap)
i[e]=[],i[e].push(L.latLng(c.lat,c.lng)),a++}}}e++}return i},_vincenty_direct:function(t,a,n,s){var i,e=t.lat.toRadians(),o=t.lng.toRadians(),h=a.toRadians(),l=n,r=this.datum.ellipsoid.a,g=this.datum.ellipsoid.b,c=this.datum.ellipsoid.f,M=Math.sin(h),p=Math.cos(h),L=(1-c)*Math.tan(e),d=1/Math.sqrt(1+L*L),u=L*d,_=Math.atan2(L,p),v=d*M,f=1-v*v,y=f*(r*r-g*g)/(g*g),N=1+y/16384*(4096+y*(-768+y*(320-175*y))),I=y/1024*(256+y*(-128+y*(74-47*y))),R=l/(g*N),P=0
do{var m=Math.cos(2*_+R),T=Math.sin(R),G=Math.cos(R),w=I*T*(m+I/4*(G*(-1+2*m*m)-I/6*m*(-3+4*T*T)*(-3+4*m*m)))
i=R,R=l/(g*N)+w}while(Math.abs(R-i)>1e-12&&++P)
var b=u*T-d*G*p,E=Math.atan2(u*G+d*T*p,(1-c)*Math.sqrt(v*v+b*b)),S=Math.atan2(T*M,d*G-u*T*p),D=c/16*f*(4+c*(4-3*f)),B=S-(1-D)*c*v*(R+D*T*(m+D*G*(-1+2*m*m)))
if(s)var C=(o+B+3*Math.PI)%(2*Math.PI)-Math.PI
else var C=o+B
var q=Math.atan2(v,-b)
return{lat:E.toDegrees(),lng:C.toDegrees(),finalBearing:q.toDegrees()}},_vincenty_inverse:function(t,a){var n,s=t.lat.toRadians(),i=t.lng.toRadians(),e=a.lat.toRadians(),o=a.lng.toRadians(),h=this.datum.ellipsoid.a,l=this.datum.ellipsoid.b,r=this.datum.ellipsoid.f,g=o-i,c=(1-r)*Math.tan(s),M=1/Math.sqrt(1+c*c),p=c*M,L=(1-r)*Math.tan(e),d=1/Math.sqrt(1+L*L),u=L*d,_=g,v=0
do{var f=Math.sin(_),y=Math.cos(_),N=d*f*d*f+(M*u-p*d*y)*(M*u-p*d*y),I=Math.sqrt(N)
if(0==I)return 0
var R=p*u+M*d*y,P=Math.atan2(I,R),m=M*d*f/I,T=1-m*m,G=R-2*p*u/T
isNaN(G)&&(G=0)
var w=r/16*T*(4+r*(4-3*T))
n=_,_=g+(1-w)*r*m*(P+w*I*(G+w*R*(-1+2*G*G)))}while(Math.abs(_-n)>1e-12&&++v<100)
if(v>=100)return console.log("Formula failed to converge. Altering target position."),this._vincenty_inverse(t,{lat:a.lat,lng:a.lng-.01})
var b=T*(h*h-l*l)/(l*l),E=1+b/16384*(4096+b*(-768+b*(320-175*b))),S=b/1024*(256+b*(-128+b*(74-47*b))),D=S*I*(G+S/4*(R*(-1+2*G*G)-S/6*G*(-3+4*I*I)*(-3+4*G*G))),B=l*E*(P-D),C=Math.atan2(d*f,M*u-p*d*y),q=Math.atan2(M*f,-p*d+M*u*y)
return B=+B.toFixed(3),{distance:B,initialBearing:C.toDegrees(),finalBearing:q.toDegrees()}},_intersection:function(t,a,n,s){var i=t.lat.toRadians(),e=t.lng.toRadians(),o=n.lat.toRadians(),h=n.lng.toRadians(),l=(+a).toRadians(),r=(+s).toRadians(),g=o-i,c=h-e,M=2*Math.asin(Math.sqrt(Math.sin(g/2)*Math.sin(g/2)+Math.cos(i)*Math.cos(o)*Math.sin(c/2)*Math.sin(c/2)))
if(0==M)return null
var p=Math.acos((Math.sin(o)-Math.sin(i)*Math.cos(M))/(Math.sin(M)*Math.cos(i)))
isNaN(p)&&(p=0)
var L=Math.acos((Math.sin(i)-Math.sin(o)*Math.cos(M))/(Math.sin(M)*Math.cos(o)))
if(Math.sin(h-e)>0)var d=p,u=2*Math.PI-L
else var d=2*Math.PI-p,u=L
var _=(l-d+Math.PI)%(2*Math.PI)-Math.PI,v=(u-r+Math.PI)%(2*Math.PI)-Math.PI
if(0==Math.sin(_)&&0==Math.sin(v))return null
if(Math.sin(_)*Math.sin(v)<0)return null
var f=Math.acos(-Math.cos(_)*Math.cos(v)+Math.sin(_)*Math.sin(v)*Math.cos(M)),y=Math.atan2(Math.sin(M)*Math.sin(_)*Math.sin(v),Math.cos(v)+Math.cos(_)*Math.cos(f)),N=Math.asin(Math.sin(i)*Math.cos(y)+Math.cos(i)*Math.sin(y)*Math.cos(l)),I=Math.atan2(Math.sin(l)*Math.sin(y)*Math.cos(i),Math.cos(y)-Math.sin(i)*Math.sin(N)),R=e+I
return R=(R+3*Math.PI)%(2*Math.PI)-Math.PI,{lat:N.toDegrees(),lng:R.toDegrees()}},_merge_options:function(t,a){var n={}
for(var s in t)n[s]=t[s]
for(var s in a)n[s]=a[s]
return n}}),L.geodesic=function(t,a){return new L.Geodesic(t,a)},function(){var t=L.GeoJSON.geometryToLayer
L.GeoJSON.geometryToLayer=function(a,n,s,i){if(a.properties&&a.properties.geodesic){var e,o="Feature"===a.type?a.geometry:a,h=o.coordinates,l=a.properties
switch(s=s||this.coordsToLatLng,l.geodesic_steps&&(i=L.extend({steps:l.geodesic_steps},i)),l.geodesic_wrap&&(i=L.extend({wrap:l.geodesic_wrap},i)),o.type){case"LineString":return e=this.coordsToLatLngs(h,0,s),new L.Geodesic([e],i)
case"MultiLineString":return e=this.coordsToLatLngs(h,1,s),new L.Geodesic(e,i)
default:console.log("Not yet supported drawing GeoJSON "+o.type+" as a geodesic: Drawing as non-geodesic.")}}return t.apply(this,arguments)}}()